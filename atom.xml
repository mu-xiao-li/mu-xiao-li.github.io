<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小璃の小窝</title>
  
  <subtitle>Every day is good</subtitle>
  <link href="https://mu-li.cn/atom.xml" rel="self"/>
  
  <link href="https://mu-li.cn/"/>
  <updated>2021-05-17T02:58:31.000Z</updated>
  <id>https://mu-li.cn/</id>
  
  <author>
    <name>慕小璃吖~</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构那些事</title>
    <link href="https://mu-li.cn/2021/05/10/java/java-data-structure/"/>
    <id>https://mu-li.cn/2021/05/10/java/java-data-structure/</id>
    <published>2021-05-10T02:58:30.000Z</published>
    <updated>2021-05-17T02:58:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>本篇大多参考于《我的第一本算法书》，有兴趣的同学可以去购买阅读，书内有非常多的插图非常便于理解，也是比较推荐入门算法的一本书。<br>相信一定会让你对算法有很大程度的了解。当然如果有囊中羞涩的同学，也可以联系我下载电子版的。</p><a id="more"></a>    <div id="aplayer-FqHGXpQy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28798705" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h1 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a><strong>什么是数据结构？</strong></h1><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在学习任何东西前我们得先知道他是什么，他是用来干嘛的，这是学习一样东西的惯性思维;</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><code>数据结构</code>这一名词其实在开发中经常用到，从字面意思我们也可以知道它是指代组织数据的结构描述，我们经常问到到的就是在与前端或者后端对接<code>api</code>时会问到“接口的传参数据结构发一下”类似话语，而我们平时用到的这个名词确实是字面意思，当然如果是这样的话这篇博客也就到这里了。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>而我接下来要说的就是更加学术化，专业化上所认知的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450?fr=aladdin">数据结构</a>。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们先看看百度百科怎么说的：</p><p><em>“<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370">数据</a>结构是<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>存储、组织<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>的方式。数据结构是指相互之间存在一种或多种特定关系的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储<a href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847">效率</a>。数据结构往往同高效的检索<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025">算法</a>和<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853">索引</a>技术有关。”</em></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们可以看到，在百度百科的解释里出现了很多陌生的名词词汇，当然我们可以先忽略他们，从中提取重要信息点：<strong>“精心选择的数据结构可以带来更高的运行或者存储<a href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847">效率</a>。”</strong>，从这句话我们可以知道，数据结构在编程世界里的重要地位，为什么这么说呢？作为一名合格的程序员你应当知道，高速度低损耗是所有程序设计的终极目标，而数据结构的实际作用主要在计算机底层（这里的话需要你有一定的计算机原理知识可能才能看懂这句），从底层优化永远是比你在外层优化要得到收益更高的。其实说这么多，也还没有对数据结构这一名词进行一句话的总结，其实在我看来数据结构无非就是：</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>“同样的数据，你用不同的组织方式决定了数据的顺序和位置关系传输给了电脑。”</p><p><strong><em><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>想要算法学的好，数据结构少不了。</em></strong></p><p>（算法的重要性我会在一篇博客专门说到）–<del>鸽警告</del></p><br/><h1 id="电话簿里的数据结构"><a href="#电话簿里的数据结构" class="headerlink" title="电话簿里的数据结构"></a><strong>电话簿里的数据结构</strong></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇大多参考于《我的第一本算法书》，有兴趣的同学可以去购买阅读，书内有非常多的插图非常便于理解，也是比较推荐入门算法的一本书。&lt;br&gt;相信一定会让你对算法有很大程度的了解。当然如果有囊中羞涩的同学，也可以联系我下载电子版的。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://mu-li.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://mu-li.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://mu-li.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="计算机" scheme="https://mu-li.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>我也不知道应该叫啥的电脑配置说明</title>
    <link href="https://mu-li.cn/2021/04/21/rests/computerConfiguration/"/>
    <id>https://mu-li.cn/2021/04/21/rests/computerConfiguration/</id>
    <published>2021-04-21T07:23:02.000Z</published>
    <updated>2021-04-21T07:23:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="一、-台式电脑的组成"><a href="#一、-台式电脑的组成" class="headerlink" title="一、 台式电脑的组成"></a>一、 台式电脑的组成</h2><p>这里主要是简单的将组一台电脑的一些组件进行分类和名词说明，这对电脑的一些名词了解很重要，这里只做简单描述，具体说明在以下目录详看。</p><h3 id="1-外设"><a href="#1-外设" class="headerlink" title="1.外设"></a>1.外设</h3><p>a)    <strong>显示器：</strong>就是指电脑屏幕，电脑对用户进行显示的输出设备</p><p>b)    <strong>鼠标键盘：</strong>用户对电脑进行操作的输入设备</p><h3 id="2-机箱"><a href="#2-机箱" class="headerlink" title="2.   机箱"></a>2.   机箱</h3><h4 id="a-CPU-数据处理器："><a href="#a-CPU-数据处理器：" class="headerlink" title="a)    CPU/数据处理器："></a>a)    <strong>CPU/数据处理器：</strong></h4><p>电脑芯片，也是对电脑系统发出指令的部分，一般是对数据进行处理的芯片（数据传输、计算等）<a href="https://baike.baidu.com/item/%E7%94%B5%E8%84%91cpu/15892789?fr=aladdin">百度百科</a></p><p><img src="https://i.loli.net/2021/04/21/AKz2nW5JNCmekqy.jpg" alt="clip_image001.jpg" loading="lazy"></p><h4 id="b-显卡-图像处理器："><a href="#b-显卡-图像处理器：" class="headerlink" title="b)    显卡/图像处理器："></a>b)    <strong>显卡/图像处理器：</strong></h4><p>电脑芯片，一般用于对图像的渲染（非常块），当然也可以进行数据的处理（效率比cpu差），但是它对图像的处理有特别的优化（术业有专攻）</p><p><img src="https://i.loli.net/2021/04/21/rACu4yZk5nzDdxj.jpg" alt="clip_image003.jpg" loading="lazy"></p><h4 id="c-内存："><a href="#c-内存：" class="headerlink" title="c)    内存："></a>c)    <strong>内存：</strong></h4><p>指电脑的闪存或者说运行内存，它的大小可以决定电脑可以同时运行的程序数量</p><p><img src="https://i.loli.net/2021/04/21/9IoMwpdTY6qj5Cg.jpg" alt="clip_image005.jpg" loading="lazy"></p><h4 id="d-硬盘："><a href="#d-硬盘：" class="headerlink" title="d)    硬盘："></a>d)    <strong>硬盘：</strong></h4><p>是指电脑的储存，用于文件的写入和读取的（存储、读取），一般分为两种（固态和机械，详细会在下面细说）</p><p><img src="https://i.loli.net/2021/04/21/Bj5yTi8vsoweDgX.jpg" alt="clip_image006.jpg" loading="lazy"></p><h4 id="e-散热器："><a href="#e-散热器：" class="headerlink" title="e)    散热器："></a>e)    <strong>散热器：</strong></h4><p>对芯片进行降温的装置，这会直接影响芯片的运作性能，一般为风冷或者水冷（一般显卡会自带风冷</p><p><img src="https://i.loli.net/2021/04/21/QlLi7GNbugTa9rK.jpg" alt="clip_image008.jpg" loading="lazy"></p><h4 id="f-主板："><a href="#f-主板：" class="headerlink" title="f)     主板："></a>f)     <strong>主板：</strong></h4><p>将以上所有组件进行集成的电路板，内部有相应的程序对这些硬件进行集成管理，主板的功率会直接影响芯片的运作水平。</p><p><img src="https://i.loli.net/2021/04/21/luI4my3jfqE126Y.jpg" alt="clip_image009.jpg" loading="lazy"></p><h4 id="g-其他："><a href="#g-其他：" class="headerlink" title="g)    其他："></a>g)    <strong>其他：</strong></h4><p>不是特别重要的部分，如机箱、扩展接口等</p><h2 id="二、-外设部分详解"><a href="#二、-外设部分详解" class="headerlink" title="二、 外设部分详解"></a>二、 外设部分详解</h2><p>外设部分就是上面所讲的显示屏和鼠标键盘之类，鼠标键盘一般看个人，这里就重点讲一下显示器</p><h3 id="1-显示器（重要参数）"><a href="#1-显示器（重要参数）" class="headerlink" title="1.   显示器（重要参数）"></a>1.   显示器（重要参数）</h3><h4 id="a-屏幕色域："><a href="#a-屏幕色域：" class="headerlink" title="a)    屏幕色域："></a>a)    <strong>屏幕色域：</strong></h4><p>指屏幕能够显示的色彩丰富程度，通常单位为%，目前正常屏幕的色域是45% ，72%称为高色域屏幕，目前最高为100%色域，色域越高对画面色彩的渲染度就越高，直观感受就是会更饱满真实（一般画画的话肯定标配，这样你在自己电脑的弄完在别人电脑上显示色彩不会说不同的太离谱）</p><h4 id="b-屏幕刷新率："><a href="#b-屏幕刷新率：" class="headerlink" title="b)    屏幕刷新率："></a>b)    <strong>屏幕刷新率：</strong></h4><p><strong>一般指屏幕一秒种最多可渲染的图片数量（动画是由图片在一个时间里连续播放所呈现的），</strong>所以同样的时间里渲染的图片越多画面呈现出来就会越流畅<strong>，单位一般为</strong>Hz，指的就是一秒所渲染的图片数量。当前普通屏幕的刷新率为60Hz，通常手机屏幕就是这个刷新率，大部分电脑也是这个刷新率，高刷新率一般指大于120Hz的屏幕，游戏帧率的显示会受屏幕刷新率的影响</p><h4 id="c-其他："><a href="#c-其他：" class="headerlink" title="c)    其他："></a>c)    <strong>其他：</strong></h4><p><strong>如色准等（不太了解）</strong></p><h2 id="三、-重要硬件部分"><a href="#三、-重要硬件部分" class="headerlink" title="三、 重要硬件部分"></a>三、 重要硬件部分</h2><h3 id="1-CPU"><a href="#1-CPU" class="headerlink" title="1.   CPU"></a>1.   CPU</h3><p>CPU的话品牌很多，我就拿最出名也是最优秀的两个代表来说吧，分别是AMD和英特尔，以下详细说一下cpu涉及到的一些重要参数以及命名方式还有作用。</p><h4 id="a-核心数："><a href="#a-核心数：" class="headerlink" title="a)    核心数："></a>a)    <strong>核心数：</strong></h4><p><strong>核心数是指cpu的指令集数量</strong>，他们都可以视为一个单独的<strong>“工作室“</strong>，他们的作用就是可以将一个事拆分成多个部分进行奔跑（这样效率就会变高），但并不是核心数越多越好，比如有一些程序他只需要少量核心去运算，这个时候就需要<strong>单核性能</strong>足够强劲了（<strong>代表：</strong>如游戏），一般多核心运算会出现在对数据的计算中（如：保存文件，同时运行多个程序），所以聪明的设计师们将核心又分为大核和小核（大核跑游戏，小核跑日常）</p><blockquote><p>一般核心数与线程数相同，当然线程数其实可以视为细化的核心概念。</p></blockquote><h4 id="b-频率："><a href="#b-频率：" class="headerlink" title="b)    频率："></a><strong>b)</strong>    <strong>频率：</strong></h4><p><strong>具体我也不清楚是啥意思，反正就是会影响cpu的运算。越高越好（</strong>2666MHz为正常偏上水平<strong>）</strong></p><h4 id="c-主频："><a href="#c-主频：" class="headerlink" title="c)    主频："></a><strong>c)</strong>    <strong>主频：</strong></h4><p><strong>单位GHz，一般指耗电量和性能的比值，越大它就越强，但是耗电也就越大，主板的供电也就要更大</strong></p><h4 id="d-制程工艺："><a href="#d-制程工艺：" class="headerlink" title="d)    制程工艺："></a>d)    <strong>制程工艺：</strong></h4><p>纳米单位，越小越好，目前成熟工艺是14纳米，指单个计算单元的大小，越小说明芯片可以存在更多的运算单元</p><h4 id="e-命名"><a href="#e-命名" class="headerlink" title="e)    命名"></a><strong>e)</strong>    <strong>命名</strong></h4><blockquote><p><strong>①</strong>  <strong>英特尔命名：</strong></p></blockquote><p><strong>1.</strong>    <strong>i3：低端架构</strong></p><p><strong>举例型号：i3-3229Y</strong></p><p><strong>其中i3是型号，数字越大越好</strong></p><p><strong>-3xxxx中的3是指代数，</strong>即第三代i3CPU.一般为一年发布一代，代数越高越好，工艺架构就越成熟</p><p>后面字母Y是指芯片命名后缀，一般带有一定意思（直接附图吧，我也不是很清楚，但是就知道HK代表可超频但是功耗增高，通常都是hk，K超频cpu就发挥满实力的版本）</p><p><img src="https://i.loli.net/2021/04/21/3EmNv6VRuGIn78J.png" alt="clip_image010.png" loading="lazy"></p><p><strong>然后以下命名就都是差不多了，现在cpu已经出在第十代了，一般都会选择i5，因为性价比比较高</strong></p><p><strong>2.</strong>    <strong>i5：中端架构</strong></p><p><strong>3.</strong>    <strong>i7：高端架构</strong></p><p><strong>4.</strong>    <strong>i9：专业架构</strong></p><blockquote><p><strong>②</strong>  <strong>AMD命名：</strong></p></blockquote><p><strong>1.</strong>    <strong>R3\R5\R7\R9 直接对标英特尔（死对头了）</strong></p><p><strong>注意啊，一般同代amd的cpu都会比英特尔弱一个层级，比如r7九代介于i7九代和i5九代之间，当然amd的cpu会更加便宜，这个具体的区别就需要百度知乎了</strong></p><p><strong>cpu的主要作用就是对数据的处理，我们平时的日常使用和操作都跟cpu有关，比如你在听歌，你在保存一个文件，你在读取一个文件，cpu的强弱会大大影响你的这些数据传输和运算的速度 所以关键词就是 数据量庞大时就需要更加厉害的cpu了</strong></p><blockquote><p><strong>例子：</strong></p></blockquote><p>​    <strong>战争游戏：</strong>因为双方都有很大的士兵，数量庞大，cpu需要计算每个士兵的行为，所以士兵越多cpu负担就越大，就会越卡（而且这种游戏一般画质不会很高，所以比较吃cpu而不是吃显卡，典型的还有 英雄联盟 当你吃鸡的时候 人多的地方会卡</p><p>​    <strong>我的世界：</strong>画面差，但是cpu需要渲染每一个方块，而我的世界的方块数量你是知道的，特别是流水的时候对水流运动的运算。但是一定情况下也是显卡杀手（画质变态的模组）</p><p>​    <strong>综上：数据量和cpu是挂钩的</strong></p><h3 id="2-显卡"><a href="#2-显卡" class="headerlink" title="2.   显卡"></a>2.   显卡</h3><p><strong>先看</strong><a href="https://vga.zol.com.cn/soc/"><strong>天梯图</strong></a><strong>（点击跳转）</strong></p><p>显卡的了解我也不是特别多，无非就是一些比较有名的显卡，以及显卡的作用，这里就简单说一下吧。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h4><p>显卡上面说过是图像处理芯片，字如其名，他是用来进行图像渲染的，我们在显示屏上所看到的画面就是由显卡进行渲染的。</p><p>由此我们可以知道，当画面复杂度越高渲染成本也就越高（这里所指的画面复杂度不仅仅是色彩），具体表现可以为屏幕的像素密度越高时渲染成本就越高，因为显卡需要渲染的像素点就越多，这是数量上会对显卡进行影响的地方。</p><p>另外就是维度了，普通场景下显卡所渲染的画面都是2D的，而2D一般只有一个面，而且只需要渲染我们当期所看到的，而3D不一样，3D是对画面进行环状渲染，不仅仅是我们屏幕所看到的，因为3D的视角不再是从一个方向出发，我们永远不知道你下一秒会从哪个方向来看3D,所以显卡需要提前渲染环状范围的画面。</p><p>从以上结论就可以知道。显卡对电脑的影响是在视觉方面的，尤其是精致的画面渲染和3D的场景，所以显卡的需求方向是：<strong>建模、游戏、高像素屏幕、高刷新屏幕等 一切跟画面有关的就跟显卡有关系</strong></p><h4 id="举例显卡："><a href="#举例显卡：" class="headerlink" title="举例显卡："></a><strong>举例显卡：</strong></h4><p><strong>当前显卡比较出名的是nv的，显卡的命名如下</strong></p><blockquote><p><strong>10系：</strong>一般由10开头 如 1060 1080 </p></blockquote><blockquote><p><strong>特殊系：</strong>（16系） 1650 、 1660ti 、 1660s 、1660</p></blockquote><blockquote><p><strong>20系：</strong>rtx2060 、 rtx2080</p></blockquote><blockquote><p><strong>30系</strong>  rtx 3060 rtx3070 rtx3080</p></blockquote><p>以上命名我们可以看出和cpu有点相似，目前最新一代是30系，而命名主要有三个部分组成</p><p><u><strong>①  字母 ②数字 ③字母</strong></u></p><p>①  这里一般只出现RTX，代表光追，说明这款显卡具有光追功能（**光追就是对光线渲染的模拟功能，在游戏或者其他场景中对光线的渲染会很真实且自动化[在没出现光追技术的时候那些阳光阴影什么的都是画手一个画面一个画面的画过去的，非常耗时耗力，有了光追你只要告诉显卡一个光源点它就能自动渲染出来这些光和影子的效果]**）</p><p>②  这里数字一般就是正统型号了，一般由四位数字组成，前两位数字（这里统一举例1660）<strong>16</strong> 是指系数（越大越高级） 而后面的 <strong>60</strong> 是指在这个系数里的档次，一般有三档（60，70，80），对应普通、中级、高级，特殊档有 50 或者 90 ，反正越大越好 如 <strong>1650</strong> 和 <strong>RTX3090</strong></p><p>③  <strong>这里的字母和cpu的后缀一样，但是它没有cpu的那么繁杂，一般只有三种命名：</strong></p><ul><li><strong>无字母</strong>：常规版本 如：1660</li><li><strong>Ti:代表升级版</strong>，会比常规版厉害10%~30% 如 1660Ti</li><li>**S(简写)**：高级版，会比常规版厉害20%~60% 如 1660S</li></ul><p>显卡还区分厂商，同样的显卡可能出自不同的厂商，我们上面所说的显卡都是NV家的，但是NV在显卡发布后会提供设计图给显卡生产厂商，而这里就会引入一个概念：</p><blockquote><p>①  公版：<strong>NV自己生产的 一般为发布价格（一般产能较低，就一卖设计图纸的）</strong></p></blockquote><blockquote><p>②  非公版：<strong>其他厂商生产的 一般跟公版不会有很大区别，甚至有些会比公版的更厉害，但是非公版会比公版贵300~600不等（是显卡市场的主要货源）</strong></p></blockquote><blockquote><p>③  丐版：<strong>一般指一些技术比较差的厂商生成的，可能比不上以上两个，但并不是说有问题，但是它的有点是比公版便宜大概300~600</strong></p></blockquote><p>以上虽说是不同厂商生成的显卡，但他是同一种显卡，只是做工外形可能有区别，但是性能基本相差无几，这些不要混淆了，目前显卡NV比较出名，所以只举例说它（详细看<a href="https://vga.zol.com.cn/soc/"><strong>天梯图</strong></a>）</p><h3 id="3-内存条"><a href="#3-内存条" class="headerlink" title="3.   内存条"></a>3.   内存条</h3><p>内存条的大小决定你可以同时运行的程序数量或者程序的体量</p><p>内存的概念是什么呢，它有另外一个名字，叫做闪存，意思就是它只是做一瞬间的储存。</p><p><strong>我们都知道程序在运行时会产生各种数据</strong>，比如你在输入框上输入一段话，但是当你把程序关闭时，再来看你就发现输入框上的字就没了，再举个例子，你在做建模作业，这个时候你的建模数据是存在你的电脑内存当中，然后突然程序崩溃了，然后你也崩溃了，为什么？？ 因为你没有保存，但是我刚刚说过你的作业是存在内存中的，那为什么程序关闭了，没有保存呢？？</p><p>这就是内存概念，他是用来对正在运行的程序进行数据暂时的储存的，就好像公交车、酒店，所有人都可以坐都可以住，但是不是属于他的，一但它离开，关于他的一切就会被销毁，这个空间就会被腾出来</p><p><strong>那为什么程序运行需要内存呢，举个例子，你现在是一个程序，你从家里出门去超市买东西，去超市买东西呢就是你这个程序在运行，然后你去拿购物车，这个购物车我们可以看做是内存，然后你买了苹果、香蕉放在了购物车里，这些水果就是你这个程序运行产生的数据，但是突然保安把你轰了出去，扣下了你的购物车，然后把水果全丢了，这个我们就可以看做是程序崩溃或者退出，水果会在你的家里嘛？？？不会因为你还没有回家，那我们可以把你回家这个过程看作是在向电脑的磁盘保存数据，所以这个家就是磁盘，我们把这个保存的过程叫持久化，而你刚刚被保安轰走后，那辆购物车又到了其他人手里，但是它能看见你之前的水果嘛？？？</strong></p><p><strong>显然是不能的，在他拿到购物车之前你的水果要不就被保安丢了，要不就是被你带回家了，所以内存当中的数据具有隔离性，程序在运行当中或者在你关闭后是访问不到属于你运行时在内存产生的数据的，其实内存也是一个磁盘，只不过他一直在接待不同的程序，删除、新增、删除、新增 它就是一个渣男，离开你又能忘了你 然后还能马上接受新欢</strong></p><p>通过以上例子我们对内存的概念已经有一定的了解了，所以我们就可以知道，内存越大能够同时运行的程序就越多，就能够运行那种大程序</p><p><strong>因为程序在运行中是会产生数据的，产生数据的多少取决于这个程序的体量</strong></p><p><strong>那么？？内存满了会怎么样？？</strong>你可以试试在你手机上打开20个app，你再回去访问第一个打开的app，它是不是需要重新加载进入，为什么呢，因为你手机的内存满了（这里指的是手机运行内存和电脑的内存是一个概念），内存满了就回去关闭程序，在程序打开的瞬间他就会去向内存要一定的空间作为它等会要进行运行的数据存放地，所以当内存不够时，程序就会出现闪退，一般程序被关闭除bug冲突的原因外，就是你的内存不够了。</p><p><strong>运行时的数据为什么放内存，不能放磁盘嘛？？</strong> emmm你去超市买水果，会买一个就跑回家，然后又跑到超市拿一个又跑回家嘛？？？</p><p>在内存当中的数据传输速度可比你的磁盘快的多了，如果真用磁盘当内存，那你等着每做一个数据交互就要等几秒的准备的（）你建模的时候加条线给你加载几秒，动一下又加载几秒，我估计你会砸电脑）</p><p>我们还要引入一个新的概念，<strong>多通道内存</strong></p><p>现在我们要组一个16GB内存的电脑 现在电脑上有两个内存插槽 你有三张内存条 分别是 16GB 、8GB、 8GB</p><p>请问你觉得是插一张16gb的内存好呢，还是插两张8gb的内存好呢？？</p><p>现在有100kg的水，全倒进了一个水管里，水管有10cm直径（可容纳100kg水），假设流动一千克到另一端需要一秒，那么需要100秒</p><p>同样现在有100kg的水，分成两个50kg的水，放在两根5cm(可容纳50kg*2)直径的水管，他们同时在不同水管流动，到达另外一段则只需要50秒</p><p><strong>虽然他们总共能够容纳的水含量是一样的，但是明显多个水管效率更高，在计算机上我们叫多线程（多个线程处理一件事）</strong></p><p><strong>答案就是 同样容量的内存（内存大小只影响你可以同时运行的程序数量），多通道的效率会大大多于单通道（这里所指的效率是指对数据的传输速度）</strong></p><p>内存的知识大概就是这些，有不懂的记得dd我。</p><h3 id="4-储存（硬盘）"><a href="#4-储存（硬盘）" class="headerlink" title="4.   储存（硬盘）"></a>4.   储存（硬盘）</h3><p>（持续更新中）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    <category term="电脑硬件" scheme="https://mu-li.cn/categories/%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="计算机" scheme="https://mu-li.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="知识" scheme="https://mu-li.cn/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java中的锁概念</title>
    <link href="https://mu-li.cn/2021/01/11/java/java-lock/"/>
    <id>https://mu-li.cn/2021/01/11/java/java-lock/</id>
    <published>2021-01-11T06:54:30.000Z</published>
    <updated>2021-05-10T03:19:11.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script>    <div id="aplayer-cpVvyAkZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="186005" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h1 id="锁是什么？"><a href="#锁是什么？" class="headerlink" title="锁是什么？"></a><strong>锁是什么？</strong></h1><p>   首先从字面意思来说，锁的概念就是“阻止”和“封闭”一些不能让别人访问的东西。我们可以参考百度百科<a href="https://baike.baidu.com/item/%25E9%2594%2581/379548?fr=aladdin">（锁）</a>的说法。其实不管其作用是什么但锁的核心目标就是安全，安全来说涉及的东西就多了。<br><img src="https://i.loli.net/2021/04/22/ELIDr1qPMSVHywj.jpg" alt="锁" loading="lazy"></p><p>我们可以说是为了保护一样东西，阻挡不怀好意的坏东西；当然也可以说是指定了如同权限一样的东西，所谓的安全可能涉及范围真的很广，但在程序设计中能想到跟安全有关的东西无非就那么几个大方向：系统稳定、数据异常、数据安全、访问限制等。</p><br/><p>hhh，<del>扯皮扯的挺多的了</del>，好了我们直接步入正题：</p><blockquote><p>什么是开发眼中的锁？</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>实现数据安全的权限手段</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>所谓的数据安全并非是犹如加密一样的锁概念，在这之前其实我们应该引入<span style='color: #f44336;'>多线程的概念</span>（详细见<a href="https://mu-li.cn/2020/12/04/multithreading/">《关于Java多线程的一些常问问题的刨析》</a>）</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><u><strong>“掌握Java中锁是Java多线程编程中绕不开的知识，只有知道理解Java各种锁才能在编码过程中灵活运用，写出更高效的多线程程序。”</strong></u></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这是对于多线程应用的普遍认知，从这些关系我们就可以看出，所谓开发中的“锁”并不是那么现实化，我们通常认为的锁是锁住一个物品，但在开发中它更像是一扇门一个房间，封住了一个只允许单人访问的”物品“，只有拿到钥匙的人才可以进入房间。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当然在这里所谓的钥匙也会只有一把（这是通常情况下）。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>以上都是转义化的解释，其实锁的出现无非就是解决线程冲突的问题，更术语点可以称做为<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/9747724?fr=aladdin">线程安全</a>。我们都知道多线程可以在同一时间进行不同的操作，这是我们认为最符合预期的样子，但是有没有想过，当多个线程在同一时刻对同一件事进行操作时会有什么后果？</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>显而易见的，这是会出现数据安全的；现在有三个人（A、B、C），三个人一同去称重（<strong>在程序中不管多么一同都是有先后关系的</strong>），A先站了上去，发现自己50kg；这时候他拿出本子准备记下来，反头来看称的时候B已经站上去了，于是A记下了A的体重为100kg，完了，这下A就裂开了，这数据真实嘛准确吗，显然之前的数据是已经丢失的了。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>以上就是线程安全中最典型的问题，<strong>数据安全</strong>。从不同的非常规场景可以预见更多的线程安全问题，于是便有了线程锁的出现。</p><p>因此非要说是开发眼中的“锁”的话，不如说其实它叫做<strong>线程锁</strong>。</p><br/><h1 id="怎么在java中实现锁？"><a href="#怎么在java中实现锁？" class="headerlink" title="怎么在java中实现锁？"></a><strong>怎么在java中实现锁？</strong></h1> <br/><p>  以上说了很多都是一些对锁概念的说明，我们更多的是明白怎么去使用它，怎么在实际开发中去运用它，那么怎么在java中实现锁呢？</p><br/><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a><strong>synchronized关键字</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>实现锁之前我们得先认识一个java关键字（<a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin">关键字是什么？</a>）， <a href="https://baike.baidu.com/item/java%E5%85%B3%E9%94%AE%E5%AD%97/5808816?fr=aladdin#3_37"><span style='color: #f44336;'>synchronized</span></a>（同步关键字）,作为java中实现锁的重要部分，同步关键字是唯二实现java锁机制的东西。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>synchronized关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护（百度百科的解释）。代码演示如下：</p><br/><p>作用于方法：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// todo</span><span class="token punctuation">&#125;</span></code></pre><br/><p>作用于代码块：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// todo</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><br/><p>两者只是<strong>作用范围</strong>不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。</p><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>以上我们可以视为，在synchronized关键字范围内的代码，在被访问操作时只允许一个线程进入（其他线程访问时则需要等待获得访问资格的线程完成操作后释放锁才行），而在这个其他线程进行等待的过程我们可以称之为线程阻塞（等待），由此这就是java中锁的实现和应用。</p><br/><h2 id="Lock对象"><a href="#Lock对象" class="headerlink" title="Lock对象"></a><strong>Lock对象</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们都知道所谓java关键字其实就是一个保留字，类似的如void、null等，我们上面也说到过，实现锁机制中同步关键字是唯二的实现锁方式，所以接下来就是另外一种实现锁的方式，通过对象来实现。（<em>这里插一句其实哪怕是同步关键字其实本质上也是一个对象只不过我们所看到的样子并不像，所以java中万物皆对象是真的</em>）</p><br/><p><img src="https://i.loli.net/2021/04/22/aMk2iJtVr71EfzX.jpg" alt="万物皆对象" loading="lazy"></p><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>java中提供了一个锁对象<code>Lock</code>，Lock的实现其底层其实也是对synchronized关键字底层的实现封装，其实还有更多区别，如果有想了解的话可以在评论区留言，到时候可以专门写一篇，也可以参考博客<a href="https://blog.csdn.net/weixin_45186903/article/details/104948929"><strong>《Lock接口实现类与方法》-二：synchronized的缺陷</strong></a>。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>与synchronized不同的是，Lock锁是纯Java实现的，与底层的JVM无关。在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），其实现都依赖java.util.concurrent.AbstractQueuedSynchronizer类，这里就不过多阐述。</p><br/><p><img src="https://i.loli.net/2021/04/22/fub3hCFIA6p2MQJ.png" alt="Lock的实现类" loading="lazy"></p><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>synchronized是Java原生的互斥同步锁，使用方便，对于synchronized修饰的方法或同步块，无需再显式释放锁。而ReentrantLock做为API层面的互斥锁，需要显式地去加锁解锁。采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止<a href="https://baike.baidu.com/item/%E6%AD%BB%E9%94%81/2196938?fr=aladdin">死锁</a>（你可以理解为锁的无限套娃或者说锁未释放的问题）的发生。</p><br/><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 加锁</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ... 函数主题</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//解锁</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>   作为对象去实现锁机制，它可以更加自由以及深度的定制化加锁，只不过麻烦程度肯定相比synchronized是要高的，不同的开发场景肯定是用到不用的加锁方案的，这个就需要长期的开发经验了。</p><br/><h1 id="锁的运用与分类"><a href="#锁的运用与分类" class="headerlink" title="锁的运用与分类"></a><strong>锁的运用与分类</strong></h1><br/><p>我们已经了解到锁的实现方法了，而聪明的开发人员们在实际开发中应对不同的场景所运用的锁方案进行汇总总结，形成了一些锁的分类运用，而深刻理解这一层才是合格的“锁开发”人员。首先需要知道几个名词：</p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><br/><p><strong>详细介绍</strong></p><hr><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a><strong>公平锁/非公平锁</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>所谓公平锁,顾名思义，意指锁的获取策略相对公平，当多个线程在获取同一个锁时，必须按照锁的申请时间来依次获得锁，排排队，不能插队；非公平锁则不同，当锁被释放时，等待中的线程均有机会获得锁。synchronized是非公平锁，ReentrantLock默认也是非公平的，但是可以通过带boolean参数的构造方法指定使用公平锁，但<strong>非公平锁的性能一般要优于公平锁。</strong></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>非公平锁最宏观的表现就是结果不可预测化，你永远不知道是哪一个线程被优先选择了，公平锁通常的表现可以视为从代码的先后编译来。</p><br/><blockquote><p>接下来我们从源码角度来看看ReentrantLock的实现原理，它是如何保证可重入性，又是如何实现公平锁的。</p></blockquote><p><strong>1、无参构造器（默认为非公平锁）</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认是非公平的</span><span class="token punctuation">&#125;</span></code></pre><p>sync是ReentrantLock内部实现的一个同步组件，它是Reentrantlock的一个静态内部类，继承于AQS。</p><br/><p><strong>2、带布尔值的构造器（是否公平）</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//fair为true，公平锁；反之，非公平锁</span><span class="token punctuation">&#125;</span></code></pre><p>此处可以指定是否采用公平锁，<strong>FailSync和NonFailSync亦为Reentrantlock的静态内部类，都继承于Sync</strong>。</p><br/><p>还有更多实现方式这里就不过多展现了。</p><br/><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a><strong>可重入锁</strong></h2><br/><p>   所谓的可重入性，就是<strong>可以支持一个线程对锁的重复获取</strong>，原生的synchronized就具有可重入性，一个用synchronized修饰的递归方法，因此又名<strong>递归锁</strong>，当线程在执行期间，它是可以反复获取到锁的，而不会出现自己把自己锁死的情况。ReentrantLock也是如此，在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 此处用代码演示了可重入锁的代码层意思</span><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>       <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 因为获取了setA()的锁（即获取了方法外层的锁），此时递归调用setA()将再次获取一个新锁，如果不自动获取的话方法A的递归将不会执行           </span><span class="token punctuation">&#125;</span></code></pre><br/><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a><strong>独享锁/共享锁</strong></h2><br/><blockquote><p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p></blockquote><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在一般的开发当中我们通常对读写的操作进行不同的加锁方案，最好的一个例子就是Lock的一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。</p><p>   读锁的共享可以保证在其他线程操作写入操作时，不影响正常业务的读取操作，这样可以使<a href="https://mu-li.cn/2020/12/04/multithreading/">并发</a>读的操作变得非常高效，写入操作的独享锁又能保证并发写入操作数据的安全性。</p><p>   独享锁与共享锁是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>   **抽象队列同步器(AbstractQueuedSynchronizer，简称<u>AQS</u>)**是用来构建锁或者其他同步组件的基础框架,想详细了解的话可以去查询相关的博客文章，这里就不做过多说明了。</p><br/><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a><strong>互斥锁/读写锁</strong></h2><br/><p>   其实上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><br/><blockquote><p>互斥锁</p></blockquote><p>   在访问共享资源之前进行加锁操作，在访问完成之后进行解锁操作。加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前线程解锁。如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都会变成就绪状态，第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。在这种方式下，只有一个线程能够访问被互斥锁保护的资源。举个形象的例子：多个人抢一个马桶</p><br/><blockquote><p>读写锁</p></blockquote><p>   读写锁既是互斥锁，又是共享锁，读写锁其实就是对读写操作进行加锁的统称，一般情况下我们都是采取的读操作共享，写操作独享这样的，综合上述所说其实读写锁非常适合多读少写的情况。。</p><br/><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a><strong>乐观锁/悲观锁</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>乐观锁和悲观锁并不是指具体类型的一种锁，而是一种看待并发同步操作的处理看法。</p><br/><blockquote><p>乐观锁</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>乐观锁就是在任何并发同步操作的情况中，都乐观的觉得不会出现数据冲突问题，觉得数据出现冲突的操作是不会进行实际值改变的，通过不停的反复尝试来进行值修改，通常认为不加锁也可以让并发操作不会有什么问题。</p><br/><blockquote><p>悲观锁</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>悲观锁其实就和乐观锁相反，它会觉得任何并发操作中如不过不进行加锁操作就一定会出现数据安全问题，悲观的认为不加锁的并发操作一定是不安全的，它会认为并发操作一定会影响实际值变化。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。<br>乐观锁在Java中的使用，是无锁编程，常常采用业务逻辑来进行仿锁的操作，进行多次的尝试进行值插入修改。</p><br/><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a><strong>分段锁</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及<strong>设计思想</strong>，<code>ConcurrentHashMap</code>中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><br/><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a><strong>偏向锁/轻量级锁/重量级锁</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这三种锁是指锁的状态，并且是针对<code>Synchronized</code>。在Java 5通过引入锁升级的机制来实现高效<code>Synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><blockquote><p>偏向锁</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p><strong>偏向锁的适用场景</strong></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用；</p><blockquote><p>轻量级锁</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><blockquote><p>重量级锁</p></blockquote><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>由上我们可以看到，三种状态的锁变化，会导致获取锁的成本越来越高，而在线程设计中我们必须尽量避免出现重量级锁的情况。</p><br/><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h2><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>自旋锁原理其实非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户线程和内核的切换的消耗</strong>。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>自旋锁尽可能的减少线程的阻塞，适用于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到cpu，造成cpu的浪费。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>自旋锁的话，可以理解为一个反复询问有没有开锁的线程。</p><br/><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><br/><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>锁的概念在多线程的重要程度中占据了非常的大的比例，如果对锁的概念不熟悉可以说你接下来的多线程开发会出现各种各样的问题。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>该篇博客其实也只是我个人对于锁概念的浅薄认识，如果要更加深入的理解的话，建议购买相关的专业书籍进行阅读（emmm平时不是特别喜欢看书所以也没什么推荐的，<del>误</del>）。</p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>如果有什么看不懂或者不理解的地方可以在下方登录账号后进行评论，我看到了都会进行回复的<del>(￣▽￣)”</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    <category term="Java问题刨析" scheme="https://mu-li.cn/categories/Java%E9%97%AE%E9%A2%98%E5%88%A8%E6%9E%90/"/>
    
    
    <category term="多线程" scheme="https://mu-li.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://mu-li.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于Java多线程的一些常问问题的刨析</title>
    <link href="https://mu-li.cn/2020/12/04/multithreading/"/>
    <id>https://mu-li.cn/2020/12/04/multithreading/</id>
    <published>2020-12-04T09:58:30.000Z</published>
    <updated>2021-05-10T03:19:25.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p><a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin">多线程</a>对我来说可能是比较薄弱的地方（<del>那会上课在打盹</del>），<br>然后实际开发中又用的比较少（<del>其实一直都知道多线程的重要性，主要是懒</del>），<br>这里的话就是自己这些天对多线程问题的一些整理和自我理解。</p><p>其实内容也大多都是参考别人的文档，然后加上自己的理解。</p><a id="more"></a>    <div id="aplayer-vxsrUZNE" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="518863916" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><h1 id="问题（1-10）"><a href="#问题（1-10）" class="headerlink" title="问题（1-10）"></a>问题（1-10）</h1><h2 id="①并行和并发有什么区别？"><a href="#①并行和并发有什么区别？" class="headerlink" title="①并行和并发有什么区别？"></a>①并行和并发有什么区别？</h2><p><strong>解释一</strong>：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br><strong>解释二</strong>： 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br><strong>解释三</strong>：</p><p><strong>并行</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。所以无论从微观还是从宏观来看，二者都是一起执行的。   </p><p><img src="https://i.loli.net/2020/12/04/NUsDB4WjMPKwxrf.jpg" alt="并行" loading="lazy"></p><p><strong>并发</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，<br>使多个进程快速交替的执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 </p><p><img src="https://i.loli.net/2020/12/04/Lgj9xrkz5fnqGKH.jpg" alt="并发" loading="lazy"></p><p>（其实这个问题的话可以说是明白多线程的基础问题，但其实很多人都不一定清楚真正的解释方法。<del>包括我</del>） </p><h2 id="②线程和进程的区别？"><a href="#②线程和进程的区别？" class="headerlink" title="②线程和进程的区别？"></a>②线程和进程的区别？</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫轻量级进程。<br>线程的划分小于进程，线程是隶属于某个进程的。进程是程序的一种动态形式，是CPU，内存等资源占用的基本单位，而线程是不能占有这些资源的。<br>进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信比较方便。<br>进程在执行过程中包含比较固定的入口，执行顺序，出口，而线程的这些过程会被应用程序所控制。</p><p><strong>进程</strong></p><p><img src="https://i.loli.net/2020/12/04/KbvdkCAnz7HceOf.png" alt="进程" loading="lazy"></p><p><strong>线程</strong></p><p><img src="https://i.loli.net/2020/12/04/CEvObAGhNnXfFQR.png" alt="线程" loading="lazy"></p><p>其实简单来说就是，进程就像一个工厂，一个公司（操作系统）会有多个工厂部署在不同地方，所以他们之间不能互相交流，而且他们所生产的产品<br>也不一样；而线程就像是工厂里的某一条生产线，生产线与生产线之间可以互相交流，而且他们的生产只会受该工厂负责人的管理。</p><h2 id="③守护线程是什么？"><a href="#③守护线程是什么？" class="headerlink" title="③守护线程是什么？"></a>③守护线程是什么？</h2><p><a href="https://zhuanlan.zhihu.com/p/28049750">守护线程（即daemon thread）</a>，是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种，</p><ul><li><span style="color: #C1AFBE;">前提</span></li></ul><ol><li><strong>守护线程</strong>，比如垃圾回收线程，就是最典型的守护线程。</li><li><strong>用户线程</strong>，就是应用程序里的自定义线程。</li></ol><ul><li><span style="color: #C1AFBE;">守护线程的机制</span></li></ul><ol><li>守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连<strong>main</strong>线程也执行完毕，那么<strong>jvm</strong>就会退出（即停止运行）——此时，连<strong>jvm</strong>都停止运行了，守护线程当然也就停止执行了。</li><li>再换一种说法，如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。</li><li>守护线程又被称为“服务进程”“精灵线程”“后台线程”，是指在程序运行是在后台提供一种通用的线程，这种线程并不属于程序不可或缺的部分。 通俗点讲，任何一个守护线程都是整个JVM中所有非守护线程的“保姆”。</li></ol><h2 id="④创建线程有哪几种方式？"><a href="#④创建线程有哪几种方式？" class="headerlink" title="④创建线程有哪几种方式？"></a>④创建线程有哪几种方式？</h2><p>（其实像这种问题没必要出现在这个文章的，但由于我总是忘记单词<del>英盲</del>，所以还是写在这。<del>忏悔</del>）</p><ol><li>继承<strong>Thread</strong>类，重写<strong>run</strong>方法；</li><li>实现<strong>Runnable</strong>接口，重写<strong>run</strong>方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性；</li><li>使用<strong>Executor</strong>框架创建线程池。<strong>Executor</strong>框架是<strong>juc</strong>里提供的线程池。</li></ol><ul><li><span style="color: #C1AFBE;">补充线程（Thread）相关的方法</span></li></ul><ol><li><p><strong>start()</strong>:启动线程并执行相应的run()方法</p></li><li><p><strong>run()</strong>:子线程要执行的代码放入run()方法中</p></li><li><p><strong>currentThread()</strong>:静态的，调取当前的线程</p></li><li><p><strong>getName()</strong>:获取此线程的名字</p></li><li><p><strong>setName()</strong>:设置此线程的名字</p></li><li><p><strong>yield()</strong>:调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源） </p></li><li><p><strong>join()</strong>:在A线程中调用B线程的join() 方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕， A线程再接着join()之后的代码执行</p></li><li><p><strong>isAlive()</strong>:判断当前线程是否还存活</p></li><li><p><strong>sleep(long l)</strong>:显式的让当前线程睡眠l毫秒 (只能捕获异常，因为父类run方法没有抛异常)</p></li><li><p><strong>线程通信（方法在Object类中）</strong>:wait() notify() notifyAll()</p></li><li><p><strong>getPriority()</strong>:返回线程优先值 setPriority(int newPriority)：改变线程的优先级设置线程的优先级（非绝对，只是相对几率大些）</p></li></ol><h2 id="⑤说一下-runnable-和-callable-有什么区别"><a href="#⑤说一下-runnable-和-callable-有什么区别" class="headerlink" title="⑤说一下 runnable 和 callable 有什么区别"></a>⑤说一下 runnable 和 callable 有什么区别</h2><ul><li><span style="color: #C1AFBE;">相同点</span></li></ul><ol><li>两者都是接口；（<del>废话</del>）</li><li>两者都可用来编写多线程程序；</li><li>两者都需要调用Thread.start()启动线程</li></ol><ul><li><span style="color: #C1AFBE;">不同点</span></li></ul><ol><li>两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；</li><li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</li></ol><h2 id="⑥线程有哪些状态？"><a href="#⑥线程有哪些状态？" class="headerlink" title="⑥线程有哪些状态？"></a>⑥线程有哪些状态？</h2><blockquote><p>线程状态有 5 种:新建，就绪，运行，阻塞，死亡</p></blockquote><ol><li>线程 start 方法执行后，并不表示该线程运行了，而是进入就绪状态，意思是随时准备运行，但是真正何时运行，是由操作系统决定的，代码并不能控制（<del>玄学</del>）。</li><li>同样的，从运行状态的线程，也可能由于失去了 CPU 资源，回到就绪状态，也是由操作系统决定的。这一步中，也可以由程序主动失去 CPU 资源，只需调用 yield 方法。</li><li>线程运行完毕，或者运行了一半异常了，或者主动调用线程的 stop 方法，那么就进入死亡。死亡的线程不可逆转。</li><li>下面几个行为，会引起线程阻塞：</li></ol><p>主动调用 sleep 方法。时间到了会进入就绪状态 主动调用 suspend 方法。主动调用 resume 方法，会进入就绪状态。</p><p>调用了阻塞式 IO 方法。调用完成后，会进入就绪状态。 试图获取锁。成功的获取锁之后，会进入就绪状态。 线程在等待某个通知。其它线程发出通知后，会进入就绪状态</p><h2 id="⑦sleep-和-wait-有什么区别？"><a href="#⑦sleep-和-wait-有什么区别？" class="headerlink" title="⑦sleep() 和 wait() 有什么区别？"></a>⑦sleep() 和 wait() 有什么区别？</h2><ol><li>同步锁的对待不同：</li></ol><p>**sleep()**后，程序并不会不释放同步锁。<br>**wait()**后，程序会释放同步锁。</p><ol start="2"><li>用法的不同：</li></ol><p><strong>sleep()**可以用时间指定版来使他自动醒过来。如果时间不到你只能调用</strong>interreput()<strong>来强行打断。</strong>wait()<strong>可以用</strong>notify()**直接唤起。</p><h2 id="⑧notify-和-notifyAll-有什么区别？"><a href="#⑧notify-和-notifyAll-有什么区别？" class="headerlink" title="⑧notify()和 notifyAll()有什么区别？"></a>⑧notify()和 notifyAll()有什么区别？</h2><blockquote><p>锁池</p></blockquote><p>假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个<strong>synchronized</strong>方法 (或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><blockquote><p>等待池</p></blockquote><p>假设一个线程A调用了某个对象的 wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。</p><p>而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><h2 id="⑨线程的-run-和-start-有什么区别？"><a href="#⑨线程的-run-和-start-有什么区别？" class="headerlink" title="⑨线程的 run()和 start()有什么区别？"></a>⑨线程的 run()和 start()有什么区别？</h2><p>调用 <strong>start()</strong> 方法是用来启动线程的，轮到该线程执行时，会自动调用 <strong>run()</strong> ；直接调用run()方法，无法达到启动多线程的目的，相当于主线程线性执行Thread对象的run()方法。</p><p>  一个线程对线的 start()方法只能调用一次，多次调用会抛出 <em>java.lang.IllegalThreadStateException</em> 异常; <strong>run()</strong> 方法没有限制。</p><h2 id="⑩创建线程池有哪几种方式？"><a href="#⑩创建线程池有哪几种方式？" class="headerlink" title="⑩创建线程池有哪几种方式？"></a>⑩创建线程池有哪几种方式？</h2><ol><li><p><strong>newCachedThreadPool()</strong> ，它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：</p><p>它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；<br>如果       线程闲置时间超过60秒，则被终止并移除缓存；</p><p>长时间闲置时，这种线程池，不会消耗什么资源。其内部使用<br><strong>SynchronousQueue</strong> 作为工作队列。</p></li><li><p><strong>newFixedThreadPool(int nThreads)</strong> ，重用指定数目（ <strong>nThreads</strong> ）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；</p><p>如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。</p></li><li><p><strong>newSingleThreadExecutor()</strong> ，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。</p></li><li><p> <strong>newSingleThreadScheduledExecutor()</strong> 和<strong>newScheduledThreadPool(int corePoolSize)</strong> ，创建的是个 <strong>ScheduledExecutorService</strong> ，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p></li><li><p><strong>newWorkStealingPool(int parallelism)</strong> ，这是一个经常被人忽略的线程池，<a href="https://www.runoob.com/java/java8-new-features.html">Java 8</a> 才加入这个创建方法，其内部会构建 <strong>ForkJoinPool</strong> ，利用<a href="https://blog.godiscoder.cn/%E6%8E%80%E4%BD%A0%E7%9F%AD%E8%A3%99/article/5d085d64a70b1d53db964e99">Work-Stealing</a>算法，并行地处理任务，不保证处理顺序。</p></li></ol><h1 id="问题（11-20）"><a href="#问题（11-20）" class="headerlink" title="问题（11-20）"></a>问题（11-20）</h1><h2 id="⑪线程池都有哪些状态？"><a href="#⑪线程池都有哪些状态？" class="headerlink" title="⑪线程池都有哪些状态？"></a>⑪线程池都有哪些状态？</h2><ol><li><p> <strong>RUNNING</strong> ：线程池一旦被创建，就处于 <strong>RUNNING</strong> 状态，任务数为 0，能够接收新任务，对已排队的任务进行处理。</p></li><li><p> <strong>SHUTDOWN</strong> ：不接收新任务，但能处理已排队的任务。调用线程池的  **shutdown() ** 方法，线程池由 RUNNING 转变为 SHUTDOWN 状态。</p></li><li><p> <strong>STOP</strong> ：不接收新任务，不处理已排队的任务，并且会中断正在处理的任务。调用线程池的 <strong>shutdownNow()</strong> 方法，线程池由( <strong>RUNNING</strong> 或 <strong>SHUTDOWN</strong>  ) 转变为 <strong>STOP</strong> 状态。</p></li><li><p><strong>TIDYING</strong>： <strong>SHUTDOWN</strong> 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 <strong>TIDYING</strong> 状态，会执行  <strong>terminated()</strong>  方<br>法。</p><p>线程池中的 terminated() 方法是空实现，可以重写该方法进行相应的处理。</p><p>线程池在 <strong>SHUTDOWN</strong> 状态，任务队列为空且执行中任务为空，线程池就<br>会由 <strong>SHUTDOWN</strong> 转变为 <strong>TIDYING</strong> 状态。</p><p>线程池在 <strong>STOP</strong> 状态，线程池中执行中任务为空时，就会由 STOP 转变为<br><strong>TIDYING</strong> 状态。</p></li><li><p><strong>TERMINATED</strong> ：线程池彻底终止。线程池在 <strong>TIDYING</strong> 状态执行完 <strong>terminated()</strong>  方法就会由 <strong>TIDYING</strong> 转变为 <strong>TERMINATED</strong>状态。</p></li></ol><h2 id="⑫线程池中-submit-和-execute-方法有什么区别？"><a href="#⑫线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="⑫线程池中 submit()和 execute()方法有什么区别？"></a>⑫线程池中 submit()和 execute()方法有什么区别？</h2><ol><li><p> <strong>submit(Callable task)</strong> 、 <strong>submit(Runnable task, T result)</strong> 、 <strong>submit(Runnable task)</strong> 归属于 <strong>ExecutorService</strong> 接口。</p></li><li><p><strong>execute(Runnable command)</strong> 归属于Executor接口。<strong>ExecutorService</strong>继承了 <strong>Executor</strong> 。</p></li></ol><h2 id="⑬在-java-程序中怎么保证多线程的运行安全？"><a href="#⑬在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="⑬在 java 程序中怎么保证多线程的运行安全？"></a>⑬在 java 程序中怎么保证多线程的运行安全？</h2><p>参考文章：<a href="http://www.jasongj.com/java/thread_safe/">http://www.jasongj.com/java/thread_safe/</a></p><ul><li><span style="color: #C1AFBE;">线程的安全性问题主要体现在以下几个特性：</span></li></ul><ol><li> <strong>原子性</strong> ：一个或者多个操作在 CPU 执行的过程中不被中断的特性。</li></ol><p> <strong>关于原子性，一个非常经典的例子就是银行转账问题</strong> ：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p><ol start="2"><li> <strong>可见性</strong> ：一个线程对共享变量的修改，另外一个线程能够立刻看到。</li></ol><p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p><ol start="3"><li><p><strong>有序性</strong> ：程序执行的顺序按照代码的先后顺序执行。</p><p> boolean started = false; // 语句1<br> long counter = 0L; // 语句2<br> counter = 1; // 语句3<br> started = true; // 语句4</p></li></ol><p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p><p>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</p><p>CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，完全可以放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</p><ul><li><span style="color: #C1AFBE;">导致的原因如下：</span></li></ul><ol><li>缓存导致的可见性问题</li><li>线程切换带来的原子性问题</li></ol><blockquote><p>编译优化带来的有序性问题解决办法：</p></blockquote><p> <strong>JDK Atomic</strong> 开头的原子类、 <strong>synchronized</strong> 、 <strong>LOCK</strong> ，可以解决原子性问题 <strong>synchronized</strong> 、 <strong>volatile</strong> 、 <strong>LOCK</strong> ，可以解决可见性问题 <strong>Happens-Before</strong> 规则可以解决有序性问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404?fr=aladdin&quot;&gt;多线程&lt;/a&gt;对我来说可能是比较薄弱的地方（&lt;del&gt;那会上课在打盹&lt;/del&gt;），&lt;br&gt;然后实际开发中又用的比较少（&lt;del&gt;其实一直都知道多线程的重要性，主要是懒&lt;/del&gt;），&lt;br&gt;这里的话就是自己这些天对多线程问题的一些整理和自我理解。&lt;/p&gt;
&lt;p&gt;其实内容也大多都是参考别人的文档，然后加上自己的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Java问题刨析" scheme="https://mu-li.cn/categories/Java%E9%97%AE%E9%A2%98%E5%88%A8%E6%9E%90/"/>
    
    
    <category term="多线程" scheme="https://mu-li.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Java特性" scheme="https://mu-li.cn/tags/Java%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>关于后续搬运学习笔记和原创博客的声明</title>
    <link href="https://mu-li.cn/2020/12/02/replenish/"/>
    <id>https://mu-li.cn/2020/12/02/replenish/</id>
    <published>2020-12-02T12:00:00.000Z</published>
    <updated>2020-12-03T02:24:10.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1>    <div id="aplayer-iycrWHyl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="518863916" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><blockquote><p>说实话Markdown的语法要熟悉使用可能要些时间，一旦熟悉肯定让人爱不释手。</p></blockquote><p>个人而言由于自己专业方向，其实更加偏向于html。一定要讲的话，我用html应该能玩出花来，虽然Markdown也提供html，<br>但是对于css和js的本地引入其实很茫然（<del>完全不知道</del>，有时间一定要去研究研究。）</p><p>好了回到正题，这个声明意思也很明显，接下来我会陆续在这里补上自己<strong>笔记</strong>，顺序的话就是自己的学习历程吧~~</p><p><img src="https://i.loli.net/2020/12/02/jRgdxGeXLVOvs4c.gif" alt="肥宅快乐水" loading="lazy"></p><h2 id="时间（预告）"><a href="#时间（预告）" class="headerlink" title="时间（预告）"></a>时间（预告）</h2><h3 id="2020-12-01HTML-JS-CSS"><a href="#2020-12-01HTML-JS-CSS" class="headerlink" title="2020-12-01HTML+JS+CSS"></a>2020-12-01HTML+JS+CSS</h3><p>首先引入的肯定是这前端三剑客咯，但其实作为个人博客不是很想引入这些过于基础面向的东西，因为这些笔记教程网<br>上的话会有一大把，而且比我写的更好更详细，因此对于这方面我想只会去写一些大部分不知道的或者我开发中发现的。<br>实际上对于前端开发的深入来说我也没什么太多经验（完全只在外层），毕竟我只是一个<del>秃头</del>的后端开发，也只会<br>用一些简单的前端框架。</p><p>因此接下来的搬运对我来说肯定是更有营养的内容~~</p><p><img src="https://i.loli.net/2020/12/03/wsjdtZOKA739V4B.jpg" alt="肥宅快乐水" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    <category term="小璃的声明" scheme="https://mu-li.cn/categories/%E5%B0%8F%E7%92%83%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
    
    
    <category term="声明" scheme="https://mu-li.cn/tags/%E5%A3%B0%E6%98%8E/"/>
    
    <category term="记录" scheme="https://mu-li.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始搭建一个属于自己的网站（记录学习历程）</title>
    <link href="https://mu-li.cn/2020/12/01/test/"/>
    <id>https://mu-li.cn/2020/12/01/test/</id>
    <published>2020-12-01T08:36:55.000Z</published>
    <updated>2020-12-02T07:58:59.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h1>    <div id="aplayer-xUgYTCVN" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28798705" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#C20C0C"    ></div><p><img src="https://i.loli.net/2020/03/23/bTmpQe6tgf35nj2.jpg" alt="index-preview.jpg" loading="lazy"></p><blockquote><p>一个轻、快、可爱的hexo主题。</p></blockquote><ul><li>PV: <a href="https://www.bilibili.com/video/BV17t4y1S7tz">Yun v1.0 - Strato | bilibili</a></li><li>Coding 镜像: <a href="https://yunyoujun.coding.net/public/hexo-theme-yun/hexo-theme-yun/git/files">hexo-theme-yun</a></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>其实该博客的搭建也是今天偶然从朋友那里得知的，通过了一上午的努力成功搭建。以下为学习文档，此外非常感谢<a href="https://github.com/YunYouJun">云游君</a>的开源。！！！！</p></blockquote><p>一份详细的搭建文档和使用文档</p><ul><li>云游君<code>《教你如何从零开始搭建一个属于自己的网站》</code>: <a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">https://www.yunyoujun.cn/share/how-to-build-your-site/</a></li><li>云游君<code>《使用指南》</code>: <a href="https://yun.yunyoujun.cn/guide/config.html#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">https://yun.yunyoujun.cn/guide/config.html#快速开始</a></li></ul><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><ol><li>首先你需要一个<a href="https://github.com/">GitHub</a>的账号，这个不用多说邮箱注册就ok。</li><li>准备好终端<code>win+r 输入cmd</code>，<a href="https://baike.baidu.com/item/DOS/32025?fr=aladdin">什么是DOS终端</a>。</li><li>准备好你的<strong>耐心</strong>和<strong>时间</strong>~</li></ol><p>如果你已经使用了这个主题，可以前往 <a href="https://github.com/YunYouJun/hexo-theme-yun/issues/3">Demo Sites | 示例站点</a> 留下你的站点，作者大大将会将其添加到下方的示例站点中。</p><table align="center">  <tr align="center">    <td>      <a href="https://www.yunyoujun.cn" target="_blank">        <img width="80px" src="https://www.yunyoujun.cn/images/avatar.jpg"/ loading="lazy">        <br />        <sub title="希望能成为一个有趣的人">云游君的小站</sub>        </a>    </td>    <td>      <a href="https://yuexiaoya.info" target="_blank">        <img width="80px" src="https://yuexiaoya.info/photo.jpg" alt/ loading="lazy">        <br />        <sub title="当然是用来记录历程啊，不好看怎么行！">落梅听风雪</sub>      </a>    </td>    <td>      <a href="https://blog.sernikki.cn/" target="_blank">        <img width="80px" src="https://i.loli.net/2020/03/13/xzKUC1NEj5OicfA.jpg"/ loading="lazy">        <br />        <sub title="有瑕人无玉">神崎日照の小窝</sub>      </a>    </td>    <td>      <a href="https://mesmerxx.github.io/" target="_blank">        <img width="80px" src="https://mesmerxx.github.io/girl.jpeg"/ loading="lazy">        <br />        <sub title="ヾ(❀╹◡╹)ﾉ~">mesmerxx</sub>      </a>    </td>    <td>      <a href="https://ddindex.github.io/" target="_blank">        <img width="80px" src="https://ddindex.github.io/images/avatar.jpg"/ loading="lazy">        <br />        <sub title="双手抓楼上的大胸">多酱的部落格</sub>      </a>    </td>    <td>      <a href="https://spreadwings-sky.github.io/" target="_blank">        <img width="80px" src="https://spreadwings-sky.github.io/Yun.png"/ loading="lazy">        <br />        <sub title="浊以静之徐清，安以动之徐生">俺たちに翼はない</sub>      </a>    </td>    <td>      <a href="https://www.nbamax.com/" target="_blank">        <img width="80px" src="https://www.nbamax.com/images/avatar.png"/ loading="lazy">        <br />        <sub title="YouTube NBA精彩视频分享博客!">NBA·Max</sub>      </a>    </td>    <td>      <a href="https://sblog.addesp.com/" target="_blank">        <img width="80px" src="https://www.addesp.com/avatar.jpg"/ loading="lazy">        <br />        <sub title="记录回忆，分享笔记。">ADD-SP的博客</sub>      </a>    </td>  </tr>  <tr align="center">    <td>      <a href="https://hellsakura.github.io/" target="_blank">        <img width="80px" src="https://hellsakura.github.io/images/avatar.jpg"/ loading="lazy">        <br />        <sub title="我只是一条咸鱼">琉的小窝</sub>      </a>    </td>    <td>      <a href="https://nancheng58.github.io/" target="_blank">        <img width="80px" src="https://nancheng58.github.io/images/nancheng58.jpg"/ loading="lazy">        <br />        <sub title="我好菜啊啊啊啊啊">nancheng58</sub>      </a>    </td>    <td>      <a href="https://alexzou14.github.io/" target="_blank">        <img width="80px" src="https://cdn.jsdelivr.net/gh/AlexZou14/CDN/img/touxiang.jpg"/ loading="lazy">        <br />        <sub title="笔记记录，自我激励">秩同道合的博客</sub>      </a>    </td>    <td>      <a href="https://yenpou.github.io/" target="_blank">        <img width="80px" src="https://yenpou.github.io/images/timg.jpg"/ loading="lazy">        <br />        <sub title="今朝有酒今朝醉，明日愁来明日愁">道之遠兮</sub>      </a>    </td>    <td>      <a href="http://www.romastar.cn/" target="_blank">        <img width="80px" src="https://personalblog-1301685299.cos.ap-nanjing.myqcloud.com/MyBlog-Images/Personal-Info/Avatar.jpg"/ loading="lazy">        <br />        <sub title="记录我的生活经历以及学习历程~~">柠檬君的小站</sub>      </a>    </td>    <td>      <a href="http://www.kumybryce.work" target="_blank">        <img width="80px" src="https://kumybryce.gitee.io/myblog/img/favicon.png"/ loading="lazy">        <br />        <sub title="努力一点，再努力一点">山山的掉发历程</sub>      </a>    </td>    <td>      <a href="https://hexo.cool" target="_blank">        <img width="80px" src="https://cdn.jsdelivr.net/gh/imoshanghua/file/img/avatar.jpg"/ loading="lazy">        <br />        <sub title="待我熬尽一日苦，喂你一口甜！">陌上花的小栈</sub>      </a>    </td>    <td>      <a href="https://lymtics.top" target="_blank">        <img width="80px" src="https://gitee.com/Renen/blogpic/raw/master/sources/BlogAvatar.jpg"/ loading="lazy">        <br />        <sub title="Love You More Than I Can Say.">Lymtics</sub>      </a>    </td>  </tr>  <tr align="center">    <td>      <a href="https://myperfect.work" target="_blank">        <img width="80px" src="https://myperfect.work/image/20161015094748_YFfPV.jpeg"/ loading="lazy">        <br />        <sub title="记录学习历程，每天进步一点点！">南楼画角的小站</sub>      </a>    </td>    <td>      <a href="https://copur.xyz/" target="_blank">        <img width="80px" src="https://q1.qlogo.cn/g?b=qq&nk=1935576264&s=100"/ loading="lazy">        <br />        <sub title="记录学习历程，每天进步一点点！">乐得自在的小破站</sub>      </a>    </td>    <td>      <a href="https://blog.zjgsujz.cn" target="_blank">        <img width="80px" src="https://cdn.jsdelivr.net/gh/Pakchoi1/image-host/blog/avatar.jpg"/ loading="lazy">        <br />        <sub title="it萌新的进阶之路">小白菜的博客</sub>      </a>    </td>    <td>      <a href="https://edenjohnson.me" target="_blank">        <img width="80px" src="https://cdn.jsdelivr.net/gh/MEMZSONBILI/PicGoBed@master/images/20200625174516.jpg"/ loading="lazy">        <br />        <sub title="去探索，去发现">Eden瞎写小屋</sub>      </a>    </td>    <td>      <a href="https://chitang233.github.io/" target="_blank">        <img width="80px" src="https://s1.ax1x.com/2020/06/27/N63K8e.jpg"/ loading="lazy">        <br />        <sub title="只是一个普通的初中生罢了">池某的小博客</sub>      </a>    </td>    <td>      <a href="https://xmuli.tech" target="_blank">        <img width="80px" src="https://cdn.jsdelivr.net/gh/xmuli/xmuliPic@pic/2020/xmuli_yj_256px.png"/ loading="lazy">        <br />        <sub title="与子偕臧">偕臧的小站</sub>      </a>    </td>    <td>      <a href="https://www.rogeroger.net" target="_blank">        <img width="80px" src="https://rogeroger.oss-cn-beijing.aliyuncs.com/img/rogeryu.jpeg"/ loading="lazy">        <br />        <sub title="啊啊啊啊啊啊啊啊">ROGEROGER</sub>      </a>    </td>    <td>      <a href="https://leostudiooo.github.io" target="_blank">        <img width="80px" src="https://avatars0.githubusercontent.com/u/35419343"/ loading="lazy">        <br />        <sub title="恰同学少年，风华正茂；书生意气，挥斥方遒。">LeoStudio</sub>      </a>    </td>  </tr></table><h2 id="一定要记住的命令"><a href="#一定要记住的命令" class="headerlink" title="一定要记住的命令"></a>一定要记住的命令</h2><p>本地hexo服务启动命令:</p><ul><li>在本地测试肯定不能少的命令！！</li></ul><pre><code>hexo server</code></pre><p>部署到GitHub Pages:</p><ul><li>线上更新网站~</li></ul><pre><code>hexo cleanhexo deploy</code></pre><p>备份文件到云端（常用）：</p><ul><li>这几句命令将是你以后每次备份所需要输入</li></ul><pre><code># 添加到缓存区git add -Agit commit -m &quot;这次做了什么更改，简单描述下即可&quot;# 推送至远程仓库git push# 第一次提交，你可能需设置一下默认提交分支# git push --set-upstream origin hexo</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css&quot;&gt;&lt;scrip</summary>
      
    
    
    
    <category term="小璃的教程" scheme="https://mu-li.cn/categories/%E5%B0%8F%E7%92%83%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="教程" scheme="https://mu-li.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Hexo" scheme="https://mu-li.cn/tags/Hexo/"/>
    
    <category term="分享" scheme="https://mu-li.cn/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
